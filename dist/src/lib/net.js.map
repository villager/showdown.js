{
  "version": 3,
  "sources": ["../../../src/lib/net.ts"],
  "sourcesContent": ["/***\r\n *\r\n * Network Utility functions\r\n *\r\n * @author Aldair Beltran\r\n *\r\n */\r\n\r\nimport * as https from 'https';\r\nimport * as http from 'http';\r\nimport * as url from 'url';\r\n\r\nexport const description = 'Easy way to do request from some http/s page';\r\n\r\ninterface AnyObject {\r\n\t[k: string]: any;\r\n}\r\nexport class Network {\r\n\turl: string;\r\n\treadonly protocol: string;\r\n\tconstructor(uri: string) {\r\n\t\tthis.url = uri;\r\n\t\tthis.protocol = url.parse(this.url).protocol as string;\r\n\t}\r\n\tget(): Promise<string|any> {\r\n\t\tconst net = this.protocol === 'https:' ? https : http;\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tnet.get(this.url, (res: any) => {\r\n\t\t\t\tres.setEncoding('utf8');\r\n\t\t\t\tlet data = '';\r\n\t\t\t\tres.on('data', (chunk: string) => {\r\n\t\t\t\t\tdata += chunk;\r\n\t\t\t\t});\r\n\t\t\t\tres.on('end', () => {\r\n\t\t\t\t\tresolve(data as string);\r\n\t\t\t\t});\r\n\t\t\t\tres.on('error', (err: any) => {\r\n\t\t\t\t\treject(err);\r\n\t\t\t\t});\r\n\t\t\t})\r\n\t\t\t\t.on('error', (err: any) => {\r\n\t\t\t\t\treject(err);\r\n\t\t\t\t})\r\n\t\t\t\t.setTimeout(3500);\r\n\t\t});\r\n\t}\r\n\tasync toJSON() {\r\n\t\ttry {\r\n\t\t\tconst data = await this.get();\r\n\t\t\treturn JSON.parse(data);\r\n\t\t} catch (e) {\r\n\t\t\treturn e;\r\n\t\t}\r\n\t}\r\n\trequest(opts: AnyObject) {\r\n\t\tconst net = this.protocol === 'https:' ? https : http;\r\n\t\tconst actionUrl = url.parse(this.url);\r\n\t\tconst hostname = actionUrl.hostname;\r\n\t\tconst options: AnyObject = {\r\n\t\t\thostname: hostname,\r\n\t\t\tmethod: 'POST',\r\n\t\t};\r\n\t\t// eslint-disable-next-line\r\n\t\tfor (let i in opts) {\r\n\t\t\toptions[i] = opts[i];\r\n\t\t}\r\n\t\tif (options.data) delete options.data;\r\n\t\tif (!options.hostname) options.hostname = hostname;\r\n\t\treturn new Promise((resolve, reject) => {\r\n\t\t\tlet str = '';\r\n\t\t\tconst req = net.request(options, (res: any) => {\r\n\t\t\t\tres.setEncoding('utf8');\r\n\t\t\t\tres.on('data', (chunk: string) => {\r\n\t\t\t\t\tstr += chunk;\r\n\t\t\t\t});\r\n\t\t\t\tres.on('end', () => {\r\n\t\t\t\t\tresolve(str);\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t\treq.on('error', (e: any) => {\r\n\t\t\t\treject(e);\r\n\t\t\t});\r\n\t\t\tif (opts.data) req.write(opts.data);\r\n\t\t\treq.end();\r\n\t\t});\r\n\t}\r\n}\r\nexport function Net(uri: string) {\r\n\treturn new Network(uri);\r\n}"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA,YAAuB;AACvB,WAAsB;AACtB,UAAqB;AAEd,MAAM,cAAc;AAKpB,MAAM,QAAQ;AAAA,EAGpB,YAAY,KAAa;AACxB,SAAK,MAAM;AACX,SAAK,WAAW,IAAI,MAAM,KAAK,GAAG,EAAE;AAAA,EACrC;AAAA,EACA,MAA2B;AAC1B,UAAM,MAAM,KAAK,aAAa,WAAW,QAAQ;AACjD,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,UAAI,IAAI,KAAK,KAAK,CAAC,QAAa;AAC/B,YAAI,YAAY,MAAM;AACtB,YAAI,OAAO;AACX,YAAI,GAAG,QAAQ,CAAC,UAAkB;AACjC,kBAAQ;AAAA,QACT,CAAC;AACD,YAAI,GAAG,OAAO,MAAM;AACnB,kBAAQ,IAAc;AAAA,QACvB,CAAC;AACD,YAAI,GAAG,SAAS,CAAC,QAAa;AAC7B,iBAAO,GAAG;AAAA,QACX,CAAC;AAAA,MACF,CAAC,EACC,GAAG,SAAS,CAAC,QAAa;AAC1B,eAAO,GAAG;AAAA,MACX,CAAC,EACA,WAAW,IAAI;AAAA,IAClB,CAAC;AAAA,EACF;AAAA,EACA,MAAM,SAAS;AACd,QAAI;AACH,YAAM,OAAO,MAAM,KAAK,IAAI;AAC5B,aAAO,KAAK,MAAM,IAAI;AAAA,IACvB,SAAS,GAAP;AACD,aAAO;AAAA,IACR;AAAA,EACD;AAAA,EACA,QAAQ,MAAiB;AACxB,UAAM,MAAM,KAAK,aAAa,WAAW,QAAQ;AACjD,UAAM,YAAY,IAAI,MAAM,KAAK,GAAG;AACpC,UAAM,WAAW,UAAU;AAC3B,UAAM,UAAqB;AAAA,MAC1B;AAAA,MACA,QAAQ;AAAA,IACT;AAEA,aAAS,KAAK,MAAM;AACnB,cAAQ,CAAC,IAAI,KAAK,CAAC;AAAA,IACpB;AACA,QAAI,QAAQ;AAAM,aAAO,QAAQ;AACjC,QAAI,CAAC,QAAQ;AAAU,cAAQ,WAAW;AAC1C,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACvC,UAAI,MAAM;AACV,YAAM,MAAM,IAAI,QAAQ,SAAS,CAAC,QAAa;AAC9C,YAAI,YAAY,MAAM;AACtB,YAAI,GAAG,QAAQ,CAAC,UAAkB;AACjC,iBAAO;AAAA,QACR,CAAC;AACD,YAAI,GAAG,OAAO,MAAM;AACnB,kBAAQ,GAAG;AAAA,QACZ,CAAC;AAAA,MACF,CAAC;AACD,UAAI,GAAG,SAAS,CAAC,MAAW;AAC3B,eAAO,CAAC;AAAA,MACT,CAAC;AACD,UAAI,KAAK;AAAM,YAAI,MAAM,KAAK,IAAI;AAClC,UAAI,IAAI;AAAA,IACT,CAAC;AAAA,EACF;AACD;AACO,SAAS,IAAI,KAAa;AAChC,SAAO,IAAI,QAAQ,GAAG;AACvB;",
  "names": []
}
